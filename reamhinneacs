#!/usr/bin/perl

use strict;
use warnings;
use Lingua::GA::Stemmer;

if ($#ARGV != 0 or $ARGV[0] !~ m/^(?:NN|YY|YN)[YN]$/) {
	print "Usage: reamhinneacs (YYY|YNY|YNN|YYN|NNY|NNN)\n";
	exit 1;
}

my $cineal = $ARGV[0];
my $obj;
if ($cineal =~ m/^YY/) {
	$obj = new Lingua::GA::Stemmer;
}
else {
	$obj = new Lingua::GA::Gramadoir;
}

# lower_me has been called before comparison with this table
#  stuff like "chonaic", "chuala" is ok to demutate to *"cuala", etc.
#  since we want them lumped together with "gcuala" etc.
#  "tharla" too.
my %immutable = (
	'bhuel' => 1,
	'bhur' => 1,
	'cha' => 1,
	'chan' => 1,
	'char' => 1,
	'charbh' => 1,
	'cheana' => 1,
	'chiot' => 1,
	'chomh' => 1,
	'choíche' => 1,
	'chucu' => 1,
	'chucu' => 1,
	'chugaibh' => 1,
	'chugainn' => 1,
	'chugam' => 1,
	'chugat' => 1,
	'chuici' => 1,
	'chuig' => 1,
	'chuige' => 1,
	'chun' => 1,
	'thairis' => 1,
	'thairsti' => 1,
	'thall' => 1,
	'thar' => 1,
	'tharaibh' => 1,
	'tharainn' => 1,
	'tharam' => 1,
	'tharat' => 1,
	'tharstu' => 1,
	'thart' => 1,
	'theas' => 1,
	'thiar' => 1,
	'thíos' => 1,
	'thíosluaite' => 1,
	'thoir' => 1,
	'thuaidh' => 1,
	'thuas' => 1,
	'thuasluaite' => 1,
);

my %realaitch = (
	'had' => 1,
	'hall' => 1,
	'hamilton' => 1,
	'hans' => 1,
	'harold' => 1,
	'harp' => 1,
	'harrington' => 1,
	'harris' => 1,
	'harrison' => 1,
	'harvard' => 1,
	'hata' => 1,
	# not has
	'have' => 1,
	'he' => 1,
	'head' => 1,
	'health' => 1,
	'hector' => 1,
	'height' => 1,
	'helen' => 1,
	'help' => 1,
	'her' => 1,
	'herald' => 1,
	'here' => 1,
	'heritage' => 1,
	'hidden' => 1,
	'hide' => 1,
	'higgins' => 1,
	'high' => 1,
	'hill' => 1,
	'his' => 1,
	'hitler' => 1,
	'hogan' => 1,
	'home' => 1,
	'homepage' => 1,
	'hong' => 1,
	'hospital' => 1,
	'hotel' => 1,
	'house' => 1,
	'houses' => 1,
	'housing' => 1,
	'hugh' => 1,
	'hughes' => 1,
	'human' => 1,
	'hume' => 1,
	'hurdle' => 1,
	'hussein' => 1,
	'hutton' => 1,
);

# same as in stemmer module
sub lower_me
{
	(my $inp) = @_;
	$inp =~ s/>([nt])([AEIOUÁÉÍÓÚ])/>$1-$2/;
	$inp =~ tr/A-ZÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖØÙÚÛÜİŞ/a-zàáâãäåæçèéêëìíîïğñòóôõöøùúûüış/;
	return $inp;
}

# compare stemmer "simplify"; assuming here "lower_me" has been called
# completely naive - doesn't care if it strips lenition off, say, a 
# conditional verb to produce an "incorrect" spelling.  After all,
# these stripped forms are just used for indexing
sub strip_mutation
{
	(my $word) = @_;
	return $word if (exists($immutable{$word}));
	$word =~ s/^[bdms]'//;
	$word =~ s/^[nt]-//;
	$word =~ s/^bhf/f/;
	$word =~ s/^gc/c/;
	$word =~ s/^n([dg])/$1/;
	$word =~ s/^bp/p/;
	$word =~ s/^ts/s/;
	$word =~ s/^dt/t/;
	$word =~ s/^mb/b/;
	$word =~ s/^([bcdfgmpt])h/$1/;
	$word =~ s/^sh([lnraeiouáéíóú])/s$1/;
	# in a given Irish corpus, the ^h words that are prefix-h+vowel
	# VASTLY outnumber those which are true initial-h words,
	# even including English pollution.  So the approach here,
	# stripping all h's except a few common patterns plus
	# exceptions in the realaitch hash, works quite well
	if ($word =~ /^h[aeiouáéíóú]/) {
		return $word if (exists($realaitch{$word}));
		unless ($word =~ m/^haem/ or
			$word =~ m/^halla[^s]/ or
			$word =~ m/^háít/ or
			$word =~ m/^hav/ or
			$word =~ m/^h[íi]o?dr[áei]/ or
			$word =~ m/^hiopn/ or
			$word =~ m/^hip(?:ea|i)/ or
			$word =~ m/^hoiméa/ or
			$word =~ m/^h[óo]mai/ or
		        $word =~ m/([^lnr])\1/ or
		        $word =~ m/[jkqwxyz]/) {
			$word =~ s/^h([aeiouáéíóú])/$1/;
		}
	}
	return $word;
}

sub process_me
{
	(my $foinse, my $sprioc) = @_;
	(my $docno) = $foinse =~ m/([0-9]+)\.txt$/;
	open (FOINSE, "<", $foinse) or die "Could not open source file $foinse: $!\n";
	local $/;
	my $text = <FOINSE>;
	close FOINSE;
	open (SPRIOC, ">", $sprioc) or die "Could not open target file $sprioc: $!\n";
	my $sentencenum=1;
	if ($cineal =~ m/^YY/) {
		# strip mutation on the next line is needed because the
		# stemmer is "too smart" - if a word is completely unknown
		# it won't strip mutations at all.  This is smart for
		# stuff like "chemical" but bad for new truly-Irish words
		# We choose then to strip chemical -> cemical in order
		# to make the equivalence relation defined by the 
		# aimsigh.com stemming option strictly coarser than the
		# "infhillte" option alone.
		foreach my $s (split /\n/,$obj->stem($text)) {
			print SPRIOC "<DOC>\n<DOCNO>$docno-$sentencenum</DOCNO>\n";
			$sentencenum++;
			while ($s =~ m/<[A-Z][^>]*>([^<]+)<\/[A-Z]>/g) {
				my $tok = $1;
				foreach (split / /,$tok) {  # "ar bith", etc.
					print SPRIOC strip_mutation(lower_me($_))." ";
				}
			}
			print SPRIOC "\n</DOC>\n";
		}
	}
	else {  # $cineal =~ m/^NN/ or /^YN/
		my $sentences = $obj->get_sentences($text);
		foreach my $s (@$sentences) {
			print SPRIOC "<DOC>\n<DOCNO>$docno-$sentencenum</DOCNO>\n";
			$sentencenum++;
			my $tokes = $obj->tokenize($s);
			foreach my $tok (@$tokes) {
				$tok = lower_me($tok);
				$tok = strip_mutation($tok) if ($cineal =~ m/^YN/);
				print SPRIOC $tok." ";
			}
			print SPRIOC "\n</DOC>\n";
		}
	}
	close SPRIOC;
}

binmode STDOUT, ":encoding(iso-8859-1)";
binmode STDERR, ":encoding(iso-8859-1)";
binmode STDIN, ":bytes";

my $base='/usr/local/share/crubadan/ga/ciu';
$base='/snapshot/aimsigh/caighdean' if ($cineal =~ m/^..Y$/);
my $range="/snapshot/aimsigh/$cineal";

opendir DIRH, $base or die "could not open $base: $!\n";
foreach my $doctxt (readdir DIRH) {
	next if $doctxt !~ /\.txt$/;
	print "Processing document $doctxt for $cineal index...\n";
	my $sprioc = "$range/$doctxt";
	my $foinse = "$base/$doctxt";
	my $doit = 0;
	if (-e $sprioc) {
		my @stat1 = stat($foinse);
		my @stat2 = stat($sprioc);
		$doit = ($stat1[9] > $stat2[9]);
		print "Processing (out of date)...\n" if $doit;
	}
	else {
		$doit=1;
		print "Processing (first time)...\n";
	}
	process_me($foinse, $sprioc) if ($doit);
}
closedir DIRH;
exit 0;
